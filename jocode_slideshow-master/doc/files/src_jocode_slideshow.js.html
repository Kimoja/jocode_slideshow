<h1 class="file-heading">File: src\jocode_slideshow.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
 * Copyright 2013 Joakim Carrilho de Almeida
 * http:&#x2F;&#x2F;jocode.org&#x2F;
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 *  copy of this software and associated documentation files (the
 * &quot;Software&quot;), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and&#x2F;or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *&#x2F;


&#x2F;*
 * TODO, v1
 * test  event ontouch
 * event mousewheel
 * progress class
 * change the size of the container from the contained, optional autowidth, autoHeight by default in the base class fx??? 
 * enable browsing history to change slide .... create hash for each slide, and listen onhashchange ... plugin??
 * full screen option .... HTML and CSS integration must allow it, in any case via a plugin ...
 * full of transition
 * more exemple (for test)
 * better present the documentation
 * an howto section
 **&#x2F;

 &#x2F;**
  * @class $
  *&#x2F;

(function($){
    
var empty_func = function(){},
    nil = nil,
    wrong = false,
    right = true,
    self;

$.JocodeSlideshow = $.jocodeClass(

    &#x2F;**
     * The JodecodeSlideshow constructor 
     * 
     * @class $.JocodeSlideshow
     * @constructor
     * @param {jQuery} container  The initialization container
     * @param {Object} config   The configuration object
     *      @param {String}     [config.$slides]                        The slides selector, relative to the initialization container. 
     *      @param {$.JocodeSlideshowNavigation.Base}[config.navigation]The navigation object.
     *      @param {$.JocodeProgressBar.Base}[config.progress_bar]      The progress bar object (TODO)
     *      @param {String}     [config.$buttons]                       The button selector container relative to the initialization container. 
     *                                                                  The buttons should be present in the container, and have either one of the following class: first, previous, play, pause, resume, stop, next last. 
     *                                                                  If &quot;&lt;&quot; is specified, then the initialization container will be used.
     *      @param {String}     [config.$loader]                        ...
     *      @param {String}     [config.$pause_hover]                   The selector, relative to the initialization container, which defines the elements to listen to trigger the break, on the &quot;hover&quot; event. 
     *                                                                  If &quot;&lt;&quot; is specified, then the initialization container will be used.
     *      @param {String}     [config.$mask_buttons_hover]            The selector, relative to the initialization container, that defines the elements that triggers whether to display buttons, on the &quot;hover&quot; event. 
     *                                                                  The container of buttons must be different of the container of the slideshow.
     *                                                                  If &quot;&lt;&quot; is specified, then the initialization container will be used.
     *      @param {String}     [config.$mask_nav_hover]                The selector, relative to the initialization container, that defines the elements that triggers whether to display the navigation container, on the &quot;hover&quot; event. 
     *                                                                  The parameter container of the navigation must be defined and must be different of the container of the slideshow.
     *                                                                  If &quot;&lt;&quot; is specified, then the initialization container will be used.
    *      @param {Boolean}     [config.mask_buttons_load=false]        Hide buttons during loading of a slide.
    *                                                                   The container of buttons must be different of the container of the slideshow.
    *      @param {Boolean}     [config.mask_buttons_fx=false]          Hide buttons during transition of a slide.
    *                                                                   The container of buttons must be different of the container of the slideshow.
    *      @param {Boolean}     [config.mask_nav_load=false]            Hide navigation container during transition of a slide.
    *                                                                   The parameter container of the navigation must be defined and must be different of the container of the slideshow.
    *      @param {Boolean}     [config.mask_nav_fx=false]              Hide navigation container during transition of a slide.
    *                                                                   The parameter container of the navigation must be defined and must be different of the container of the slideshow.
     *      @param {Boolean}    [config.await_nav_fx=false]             Waiting for the end of a transition for draw the change of the navigation item.
     *      @param {Boolean}    [config.await_load=false]               Waiting for the end of a loading to be able to change slide.
     *      @param {Boolean}    [config.await_fx=false]                 Waiting for the end of a transition to be able to change slide.
     *      @param {String}     [config.css_await_bt]                   Class of buttons that wait the end of a transition or a loading.
     *      @param {Boolean}    [config.touch=false]                    Allow touch swipe events to control previous&#x2F;next.
     *      @param {Boolean}    [config.touch_strength=30]              ...
     *      @param {Boolean}    [config.keyboard=false]                 Allow keyboard events to control previous&#x2F;next.
     *      @param {String}     [config.css_disable_bt]                 Class of disabled buttons.
     *      @param {Boolean}    [config.auto_play=false]                Enable Autoplay.
     *      @param {Number}     [config.delay=3000]                     Time in milliseconds between each transition .
     *      @param {Boolean}    [config.stop_event=true]                Stop event propagation and default actions.
     *      @param {Number}     [config.start_index=0]                  The start index.
     *      @param {$.JocodeSlideshowFx.Base}[config.fx]                Transition slide object.
     *      @param {Function}   [config.load]                           Loading slide function.
     *          @param {Number} config.load.index
     *      @param {Function}   [config.beforeWait]                     Custom method called  while awaiting a transition.
     *          @param {Number}     config.beforeWait.delay 
     *          @param {Number}     config.beforeWait.elapsed 
     *          @param {Number}     config.beforeWait.start_time 
     *      @param {Function}   [config.onCancel]                       Custom method called when a slide is cancelled.
     *          @param {Number}     config.onCancel.canceled_index 
     *      @param {Function}   [config.onPlay]                         Custom method called when the playback start.
     *      @param {Function}   [config.onPause]                        Custom method called when on pause.
     *      @param {Function}   [config.onResume]                       Custom method called when the playback is resumed.
     *      @param {Function}   [config.onStop]                         Custom method called when the player stops.
     *      @param {Function}   [config.onChange]                       Custom method called when a slide is changed.
     *          @param {Number}      config.onChange.new_index 
     *      @param {Function}   [config.beforeDraw]                     Custom method called before a transition.
     *      @param {Function}   [config.afterDraw]                      Custom method called adter a transition. 
     *      @param {Function}   [config.beforeSetup]                    ....
     *      @param {Function}   [config.afterSetup]                     ....
     *      @param {Function}   [config.beforeInitPile]                 ....
     *      @param {Function}   [config.isLoaded]                       Check that a slide is loaded.
     *          @param {Number}      config.isLoaded.index 
     *      @param {Function}   [config.onClick]                        ...
     *          @param {Event}      config.onClick.e 
     *          @param {jQuery}     config.onClick.slide 
     **&#x2F;
    function (container, config){
        
        var self = this,
            touch_from, touch_to, touch_strength, bt;
        
        self.container = container;
        self.config = config;
        
        config.beforeSetup &amp;&amp; config.beforeSetup.call(self);
        
        this.setConfig(config);
        
        config.onClick &amp;&amp; self.container.on(&#x27;click&#x27;, config.$slides, function(e){
            config.onClick.call(self, e, $(this));
        });
        
        config.$loader &amp;&amp; (self.loader = self.$(config.$loader));
        
        if(config.$pause_hover){
            
            self.$(config.$pause_hover).hover(
                function() {
                    if(!self._stopped &amp;&amp; !self._paused){
                         self._pause_hover = right; 
                         self._pause();
                    }
                }, 
                function() {
                    !self._stopped &amp;&amp; self._pause_hover &amp;&amp; self.resume();
                }
            );
        }
        
        if(config.keyboard){
            $(document).keyup(function(e) {
                if(e.which == 37) self.previous(); 
                else if(e.which == 39) self.next();
            });
        }
        
        if(config.touch &amp;&amp; &#x27;ontouchstart&#x27; in document.documentElement){
            
            touch_strength = config.touch_strength || 30;
            
            self.event_container.bind({
                
                touchstart : function(e){
                    
                    touch_from = e.originalEvent.touches[0].pageX;
                    touch_to = 0;
                },
                
                touchmove : function(e) {
                    
                    touch_to = e.originalEvent.touches[0].pageX;
                },
                
                touchend : function(e) {
                    
                    if (Math.abs(touch_from - touch_to) &gt; touch_strength) {
                        
                        e.preventDefault();
                        e.stopPropagation();
                        
                        touch_from &gt; touch_to ? self.next() : self.previous();
                    }
                }
            });
        }    

        if(self.navigation){
            
            self.navigation = config.navigation;
            self.navigation.init(self);
            
            if(self.navigation.container !== self.container){
                
                if(config.$mask_nav_hover){
                    
                     self.navigation.container.hide();
                    self._displayOnHover(self.$(config.$mask_nav_hover), self.navigation.container);
                }
                
                self.mask_nav_load = config.mask_nav_load;
                self.mask_nav_fx = config.mask_nav_fx;
            }
        }
            
        self.buttons = self.$(config.$buttons);
        
        $.each(&#x27;first previous play pause resume stop next last&#x27;.split(&#x27; &#x27;), function(index, button){
            
            bt = $(&#x27; .&#x27; + button, self.buttons);

            bt[0] &amp;&amp; (self[&#x27;bt_&#x27; + button] = bt.click(function(e){
                self._stopEvent(e); 
                self[button]();
            })); 
        });
        
        if(self.buttons != self.container){
            
            if(config.$mask_buttons_hover){
                
                self.buttons.hide();
                self._displayOnHover(self.$(config.$mask_buttons_hover), self.buttons);
            }
            
            self.mask_buttons_load = config.mask_buttons_load;
            self.mask_buttons_fx = config.mask_buttons_fx;
        }
        
        self.fx.init(self);
        
        self.initPile();
        
        if(config.auto_play){
            
            self.play();
        }
        else{ 
            
            self._toogleBt(&#x27;pause resume stop&#x27;, wrong, wrong);
            self.goTo(self.start_index);
        }
        
        config.afterSetup &amp;&amp; config.afterSetup.call(self);
        
    },
    
    {
        &#x2F;**
         * The configuration object
         * 
         * @property config
         * @type {Object}
         *&#x2F;
        config : nil,
        
        &#x2F;**
         * The initialization container
         * 
         * @property container
         * @type {jQuery}
         *&#x2F;
        container : nil,
        
        &#x2F;**
         * The slides selector
         * 
         * @property $slides
         * @type {String}
         *&#x2F;
        $slides : nil,
        
        &#x2F;**
         * The slides
         * 
         * @property slides
         * @type {jQuery}
         *&#x2F;
        slides : nil,
        
        &#x2F;**
         * ...
         * 
         * @property loader
         * @type {jQuery}
         *&#x2F;
        loader : nil,

        &#x2F;**
         * The navigation object
         * 
         * @property navigation
         * @type {$.JocodeSlideshowNavigation}
         *&#x2F;
        navigation : nil,
        
        &#x2F;**
         * The container of buttons
         * 
         * @property buttons
         * @type {jQuery}
         *&#x2F;
        buttons : nil,
        
        &#x2F;**
         * The button first
         * 
         * @property bt_first
         * @type {jQuery}
         *&#x2F;
        bt_first : nil,

        &#x2F;**
         * The button previous
         * 
         * @property bt_previous
         * @type {jQuery}
         *&#x2F;
        bt_previous : nil,

        &#x2F;**
         * The button play
         * 
         * @property bt_play
         * @type {jQuery}
         *&#x2F;
        bt_play : nil,

        &#x2F;**
         * The button pause
         * 
         * @property bt_pause
         * @type {jQuery}
         *&#x2F;
        bt_pause : nil,

        &#x2F;**
         * The button resume
         * 
         * @property bt_resume
         * @type {jQuery}
         *&#x2F;
        bt_resume : nil,

        &#x2F;**
         * The button stop
         * 
         * @property bt_stop
         * @type {jQuery}
         *&#x2F;
        bt_stop : nil,

        &#x2F;**
         * The button next 
         * 
         * @property bt_next
         * @type {jQuery}
         *&#x2F;
        &#x2F;**
         * @property {jQuery} The button next 
         *&#x2F;
        bt_next : nil,

        &#x2F;**
         * The button last 
         * 
         * @property bt_last
         * @type {jQuery}
         *&#x2F;
        bt_last : nil,

        &#x2F;**
         * The css class of disabled buttons
         * 
         * @property css_disable_bt
         * @type {String}
         *&#x2F;
        css_disable_bt : nil,
        
        &#x2F;**
         * Class of buttons that wait the end of a transition or a loading
         * 
         * @property css_await_bt
         * @type {String}
         *&#x2F;
        css_await_bt : nil,
        
        &#x2F;**
         * Time in milliseconds between each transition
         * 
         * @property delay
         * @type {Number}
         * @default 3000
         *&#x2F;
        delay : 3000,
        
        &#x2F;**
         * Transition slide object
         * 
         * @property fx
         * @type {$.JocodeSlideshowFx.Base}
         *&#x2F;
        fx : nil,
        
        &#x2F;**
         * The current slide
         * 
         * @property current
         * @type {jQuery}
         *&#x2F;
        current : nil,

        &#x2F;**
         * The start index
         * 
         * @property start_index
         * @type {Number}
         * @default 0
         *&#x2F;
        start_index : 0,
        
        &#x2F;**
         * The current index
         * 
         * @property index
         * @type {Number}
         * @default -1
         *&#x2F;
        index : -1,
        
        
        &#x2F;**
         * The loading index
         * 
         * @property loading_index
         * @type {Number}
         * @default -1
         *&#x2F;
        loading_index : -1,
        
        &#x2F;**
         * Waiting for the end of a transition for draw the change of the navigation item
         * 
         * @property await_nav_fx
         * @type {Boolean}
         * @default false
         *&#x2F;
        await_nav_fx : wrong,
        
        &#x2F;**
         * Waiting for the end of a loading to be able to change slide
         * 
         * @property await_load
         * @type {Boolean}
         * @default false
         *&#x2F;
        await_load : wrong,
        
        &#x2F;**
         * Waiting for the end of a transition to be able to change slide
         * 
         * @property await_fx
         * @type {Boolean}
         * @default false
         *&#x2F;
        await_fx : wrong,
        
        
        &#x2F;**
         * Hide buttons during loading of a slide. 
         * The container of buttons must be different of the container of the slideshow.
         * 
         * @property mask_buttons_load
         * @type {Boolean}
         * @default false
         *&#x2F;
        mask_buttons_load : wrong,
        
        &#x2F;**
         * Hide buttons during transition of a slide.
         * The container of buttons must be different of the container of the slideshow.
         * 
         * @property mask_buttons_fx
         * @type {Boolean}
         * @default false
         *&#x2F;
        mask_buttons_fx : wrong,
        
        &#x2F;**
         * Hide navigation container during transition of a slide.
         * The parameter container of the navigation must be defined and must be different of the container of the slideshow.
         * 
         * @property mask_nav_load
         * @type {Boolean}
         * @default false
         *&#x2F;
        mask_nav_load : wrong,
        
        &#x2F;**
         * Hide navigation container during transition of a slide.
         * The parameter container of the navigation must be defined and must be different of the container of the slideshow.
         * 
         * @property mask_nav_fx
         * @type {Boolean}
         * @default false
         *&#x2F;
        mask_nav_fx : wrong,
        
        
        &#x2F;**
         * If the player is stopped
         * 
         * @property _stopped
         * @type {Boolean}
         * @default true
         * @private
         *&#x2F;
        _stopped : right,

        &#x2F;**
         * If the player is on pause
         * 
         * @property _paused
         * @type {Boolean}
         * @default false
         * @private
         *&#x2F;
        _paused : wrong,
        
        &#x2F;**
         * If the slide is on load
         * 
         * @property _on_load
         * @type {Boolean}
         * @default false
         * @private
         *&#x2F;
        _on_load : wrong,
        
        &#x2F;**
         * If the slide is on transition
         * 
         * @property _on_fx
         * @type {Boolean}
         * @default false
         * @private
         *&#x2F;
        _on_fx : wrong,

        &#x2F;**
         * The timestamp of the beginning of the time interval between transitions
         * 
         * @property _time
         * @type {Number}
         * @default 0
         * @private
         *&#x2F;
        _time : 0,

        &#x2F;**
         * The time delay during a break
         * 
         * @property _defer
         * @type {Number}
         * @default 0
         * @private
         *&#x2F;
        _defer : 0,

        &#x2F;**
         * The waiting timer between slides
         * 
         * @property _timeout
         * @type {Number}
         * @private
         *&#x2F;
        _timeout : nil,
        
        
        &#x2F;**
         * ....
         * 
         * @method $
         * @param {String} selector ...
         *&#x2F;
        $ : function(selector){
            
            return !selector || selector === &#x27;&lt;&#x27; ? this.container : $(selector, this.container);
        },
        
        &#x2F;**
         * Change the css classe of a set of buttons
         * 
         * @method _toogleBt
         * @param {String} buttons The set of buttons
         * @param {Boolean} enable Add or remove a css class
         * @param {Boolean} await  
         * @private
         *&#x2F;
        _toogleBt : function(buttons, enable, await){
            
            self = this;
            
            var cls = await ? self.css_await_bt : self.css_disable_bt;
            
            if(!cls)return;
            
            $.each(buttons.split(&#x27; &#x27;), function(index, bt){
                
                var button = self[&#x27;bt_&#x27; + bt];
                button &amp;&amp; (enable ? button.removeClass(cls)  : button.addClass(cls));
            });
        },
        
        &#x2F;**
         * Stop an click event
         * 
         * @method _stopEvent
         * @param {Event} e The event object
         * @param {Boolean} enable Add or remove a css class
         * @private
         *&#x2F;
        _stopEvent : function(e){

            if(this.stop_event){

                e.preventDefault();
                e.stopPropagation();
            }
        },
        
        &#x2F;**
         * Display an element on hover a container
         * 
         * @method _displayOnHover
         * @param {jQuery} container The container to listen
         * @param {jQuery} container The element to display
         * @private
         *&#x2F;
        _displayOnHover : function(container, element){

            var self = this;

            container.hover(
                function() {
                    element.show();
                }, 
                function() {
                    element.hide();
                }
            );
        },
        
        &#x2F;**
         * Go to the first slide
         * 
         * @method first
         *&#x2F;
        first : function(){

            this.goTo(0);
        },
        
        &#x2F;**
         * Go to the previous slide
         * 
         * @method previous
         *&#x2F;
        previous : function(){

            this.goTo(this.loading_index - 1);
        },
        &#x2F;**
         * Start the player
         * 
         * @method play
         *&#x2F;
        play : function(){
            
            self = this;
            
            if(!self.isPlayed()){
                
                self.index = self.loading_index = -1;
                
                self._toogleBt(&#x27;play resume&#x27;, wrong, wrong);
                self._toogleBt(&#x27;pause stop&#x27;, right, wrong);

                self._stopped = wrong;
                self.onPlay();
                
                self.goTo(self.start_index);
            }
        },
        
        &#x2F;**
         * Pause the player
         * 
         * @method pause
         *&#x2F;
        pause : function(){
                
            this._pause_hover = wrong;
            this._pause();
        },
        
        
        _pause : function(){
            
            self = this;
            
            if(self.isPlayed()){
                
                self._toogleBt(&#x27;resume&#x27;, right, wrong);
                self._toogleBt(&#x27;pause&#x27;, wrong, wrong);

                self._defer += self._on_wait ? (new Date().getTime()) - self._time : 0;
                self._paused = right;

                self.onPause();

                self._on_wait &amp;&amp; clearTimeout(self._timeout);
            }
        },
        
        &#x2F;**
         * Resume the player
         * 
         * @method resume
         *&#x2F;
        resume : function(){

            self = this;
            
            if(self._paused){
                
                self._toogleBt(&#x27;resume&#x27;, wrong, wrong);
                self._toogleBt(&#x27;pause&#x27;, right, wrong);

                self._paused = wrong;
                
                self.onResume();
                
                !self._on_fx &amp;&amp; self.keepOn(self.index);
            }
            else if(self._stopped) self.play();
        },
        
        &#x2F;**
         * Stop the player
         * 
         * @method stop
         *&#x2F;
        stop : function(){

            self = this;
            
            if(!self._stopped){

                self._toogleBt(&#x27;play&#x27;, right, wrong);
                self._toogleBt(&#x27;resume pause stop&#x27; , wrong, wrong);

                self._stopped = right;
                
                self.onStop();
                
                self._on_wait &amp;&amp; clearTimeout(self._timeout);
            }
        },
        
        &#x2F;**
         * Go to the next slide
         * 
         * @method next
         *&#x2F;
        next : function(){

            this.goTo(this.loading_index + 1);
        },
        
        &#x2F;**
         * Go to the last slide
         * 
         * @method last
         *&#x2F;
        last : function(){

            this.goTo(this.slides.length - 1);
        },
        
         &#x2F;**
         * Are there any slides after to current or loading slide (ignores loop)
         * 
         * @method hasNext
         * @param {Boolean} from_index True to test on the index, otherwise on the loading index
         * @return {Boolean}
         *&#x2F;
        hasNext : function(from_index){

            return (from_index ? this.index : this.loading_index) &lt; this.slides.length - 1;
        },
        
        &#x2F;**
         * Are there any slides previous to current or loading slide (ignores loop)
         * 
         * @method hasPrevious
         * @param {Boolean} from_index True to test on the index, otherwise on the loading index
         * @return {Boolean}
         *&#x2F;
        hasPrevious : function(from_index){

            return (from_index ? this.index : this.loading_index) &gt; 0;
        },
        
        &#x2F;**
         * If the current or loading slide is the first
         * 
         * @method isFirst
         * @param {Boolean} from_index True to test on the index, otherwise on the loading index
         * @return {Boolean}
         *&#x2F;
        isFirst : function(from_index){

            return (from_index ? this.index : this.loading_index) === 0;
        },
        
        &#x2F;**
         * If the current or loading slide is the last
         * 
         * @method isLast
         * @param {Boolean} from_index True to test on the index, otherwise on the loading index
         * @return {Boolean}
         *&#x2F;
        isLast : function(from_index){

            return (from_index ? this.index : this.loading_index) === this.slides.length - 1;
        },
        
        &#x2F;**
         * If the current or loading slide index is that passed as argument
         * 
         * @method is
         * @param {Number} index The index
         * @param {Boolean} from_index True to test on the index, otherwise on the loading index
         * @return {Boolean}
         *&#x2F;
        is : function(index, from_index){

            return (from_index ? this.index : this.loading_index) == index;
        },
        
        &#x2F;**
         * If a slide is an load
         * 
         * @method isOnLoad
         * @return {Boolean}
         *&#x2F;
        isOnLoad : function(){

            return this._on_load;
        },
        
        &#x2F;**
         * If a slide is an transition
         * 
         * @method isOnFx
         * @return {Boolean}
         *&#x2F;
        isOnFx : function(){

            return this._on_fx;
        },
        
        &#x2F;**
         * If playback is waiting for a transition
         * 
         * @method isOnWait
         * @return {Boolean}
         *&#x2F;
        isOnWait : function(){

            return this._on_wait &amp;&amp; this.isPlayed();
        },
        
        &#x2F;**
         * If the player is playing
         * 
         * @method isPlayed
         * @return {Boolean}
         *&#x2F;
        isPlayed : function(){

            return !this._stopped &amp;&amp; !this._paused;
        },
        
        &#x2F;**
         * If the player is stopped
         * 
         * @method isStopped
         * @return {Boolean}
         *&#x2F;
        isStopped : function(){

            return this._stopped;
        },
        
        &#x2F;**
         * If the player is on pause
         * 
         * @method isPaused
         * @return {Boolean}
         *&#x2F;
        isPaused : function(){

            return this._paused;
        },
        
        &#x2F;**
         * Calculate an index
         * 
         * @method computeIndex
         * @param {Number} index The index
         * @return {Number}
         *&#x2F;
        computeIndex : function(index){
            
            return index &gt;= this.slides.length ? 0 : index &lt;= -1 ? this.slides.length - 1 : index;
        },
        
        &#x2F;**
         * Method invoked when the pile of slides change
         * 
         * @method initPile
         *&#x2F;
        initPile : function(){
            
            self = this;
            
            var last_pile = self.slides;
            
            self.beforeInitPile();
            
            self.slides = $(self.$slides, self.container);
            self.fx.initPile(last_pile);
            
            self.navigation &amp;&amp; self.navigation.initPile(last_pile);
        },
        
        &#x2F;**
         * Continue playback after a transition
         * Start the timer delay between each transition, whether it is playing
         * 
         * @method keepOn
         * @param {Number} index The index
         *&#x2F;
        keepOn : function(index){
            
            var self = this;
                &#x2F;&#x2F;alert(self.loading_index)
            
            if(index !== self.loading_index)
                return;
            
            self.afterDraw();
            
            self._on_fx = wrong;
                
            self.navigation &amp;&amp; self.await_nav_fx &amp;&amp; self.navigation.draw(index);
            
            if(self.await_fx){
                
                self._toogleBt(&#x27;first previous next last&#x27;, right, right);
                self.navigation &amp;&amp; self.navigation.setAwaitCss(wrong);
            }
            
            self.mask_buttons_fx &amp;&amp; self.buttons.show();
            self.mask_nav_fx &amp;&amp; self.navigation.container.show();
            
            if(self.isPlayed()){
                
                var delay = self.delay  - self._defer;
                
                self._time = new Date().getTime();
                
                self._on_wait = right;
                
                self._timeout = setTimeout(function(){
                    
                    self._defer  = 0;
                    self._on_wait = wrong;

                    self.goTo(self.index + 1);

                }, delay);
                
                self.beforeWait(delay, self._defer, self._time);
            }
            else if(self._paused) {
                self._defer = 0;
            }
        },

        &#x2F;**
         * Launch the transition, after loading a slide
         * 
         * @method draw
         * @param {Number} index The index
         *&#x2F;
        draw : function(index){
        
            self = this;
            
            if(index != self.loading_index)
                return; 
            
            self.loader &amp;&amp;  self.loader.hide();
                
            var old_sible = self.current,
                old_index = self.index;
                 
            self._on_load = wrong; 
            self._on_fx = right;
            
            self.current = $(self.slides[index]);
            self.index = index;
            
            self.mask_buttons_load &amp;&amp; !self.mask_buttons_fx ? self.buttons.show() 
                : !self.mask_buttons_load &amp;&amp; self.mask_buttons_fx &amp;&amp; self.buttons.hide();
                
            self.mask_nav_load &amp;&amp; !self.mask_nav_fx ? self.navigation.container.show()
                : !self.mask_nav_load &amp;&amp; self.mask_nav_fx &amp;&amp; self.navigation.container.hide();
            
            
            if((self.await_load &amp;&amp; !self.await_fx) || (!self.await_load &amp;&amp; self.await_fx)){
                
                self._toogleBt(&#x27;first previous next last&#x27;, !self.await_fx, right);
                self.navigation &amp;&amp; self.navigation.setAwaitCss(self.await_fx);
            }
            
            self.beforeDraw();
            
            self.fx.draw(old_sible, self.current, old_index, index);
            self.navigation &amp;&amp; !self.await_nav_fx &amp;&amp; self.navigation.draw(index);
           
        },
        
        &#x2F;**
         * Go to slide
         * 
         * @method goTo
         * @param {Number} index The index
         *&#x2F;
        goTo : function(index){
            
            self = this;
            
            if((self.await_load &amp;&amp; self._on_load) 
                    || (self.await_fx &amp;&amp; self._on_fx))
                return;
            
            index = self.computeIndex(index);
            
            if(index === self.index){
                
                if(self._on_wait){
                    
                    clearTimeout(self._timeout);
                    self._defer = 0;
                    self.keepOn(index);
                }
                
                return;
            }
            
            if(index === self.loading_index)
                return;
            
            self._on_load = right;
            
            if(self.await_load){
                
                self._toogleBt(&#x27;first previous next last&#x27;, wrong, right);
                self.navigation &amp;&amp;  self.navigation.setAwaitCss(right);
            }
            
            self.mask_buttons_load &amp;&amp; self.buttons.hide();  
            self.mask_nav_load &amp;&amp; self.navigation.container.hide();   
            
            if(self.index !== -1){
                
                if(self._on_wait){
                    
                    self._defer = 0;
                    clearTimeout(self._timeout); 
                }
                
                self.onCancel(self.loading_index);
                self.navigation &amp;&amp; self.navigation.onCancel(self.index);
            }
            
            self.loading_index = index;
           
            self.onChange(index);
            self.navigation &amp;&amp; self.navigation.onChange(index);
            
            if(self.isLoaded(index)){
                &#x2F;&#x2F;alert(self.loading_index)
                self.draw(index)
            }
            else {
                self.loader &amp;&amp; self.loader.show();
                self.load(index);
            }
        },
        
        &#x2F;&#x2F;to override with the config object
        
        &#x2F;**
         * Load a slide
         * 
         * @method load
         * @param {Number} index The index
         *&#x2F;
        load : function(index){
            
            this.draw(index);
        },
        
        &#x2F;**
         * Check that a slide is loaded
         * 
         * @method isLoaded
         * @param {Number} index The index
         *&#x2F;
        isLoaded : function(index){
            
            return true;
        },
        
        &#x2F;**
         * Custom method called  while awaiting a transition
         * 
         * @method beforeWait
         * @param {Number} delay
         * @param {Number} elapsed
         * @param {Number} start_time
         *&#x2F;
        beforeWait : empty_func,
        
        &#x2F;**
         * Custom method called when a slide is cancelled
         * 
         * @method onCancel
         * @param {Number} canceled_index The canceled index
         *&#x2F;
        onCancel : empty_func,
        
        &#x2F;**
         * Custom method called when the playback start
         * 
         * @method onPlay
         *&#x2F;
        onPlay : empty_func,
        
       &#x2F;**
         * Custom method called when on pause
         * 
         * @method onPause
         *&#x2F;
        onPause : empty_func,
        
        &#x2F;**
         * Custom method called when the playback is resumed
         * 
         * @method onResume
         *&#x2F;
        onResume : empty_func,
        
        &#x2F;**
         * Custom method called when the player stops
         * 
         * @method onStop
         *&#x2F;
        onStop : empty_func,
        
        &#x2F;**
         * Custom method called when a slide is changed
         * 
         * @method onChange
         * @param {Number} new_index The index of a new slide
         *&#x2F;
        onChange : empty_func,
        
        &#x2F;**
         * Custom method called before a transition
         * 
         * @method beforeDraw
         *&#x2F;
        beforeDraw : empty_func,
        
        &#x2F;**
         * Custom method called after a transition
         * 
         * @method afterDraw
         *&#x2F;
        afterDraw : empty_func,
        
        
        beforeInitPile : empty_func
    }
);


$.JocodeSlideshowFx = {
    
    Base : $.jocodeClass(
    
        &#x2F;**
         * The base class of transitions between slide
         * 
         * @class $.JocodeSlideshowFx.Base
         * @constructor 
         **&#x2F;
        function(){
            
        }, 
        {
            &#x2F;**
             * The slideshow
             * 
             * @property slideshow
             * @type {$.JocodeSlideshow}
             *&#x2F;
            slideshow : nil,
            
            &#x2F;**
             * Launch the transition
             * 
             * @method draw
             * @param {jQuery} from Slide source
             * @param {jQuery} to   Slide destination
             * @param {Number} from_index The from index
             * @param {Number} to_index The to index
             *&#x2F;
            draw : empty_func,
            
            &#x2F;**
             * Initialize the transition object
             * 
             * @method init
             * @param {$.JocodeSlideshow} jocode_slideshow The slideshow
             *&#x2F;
            init : function(slideshow){

                this.slideshow = slideshow;
            },
            
            &#x2F;**
             * Method invoked when the pile of slides change
             * 
             * @method initPile
             * @param {jQuery} last_pile The last pile of slides 
             *&#x2F;
            initPile : empty_func
        }
    )
};

&#x2F;**
  * Add JocodeSlideshow as a jQuery plug-in
  * @method jocodeSlideshow
  * @param {Object} config The configuration object
  * @for $ 
  * @static
  * @return {jQuery}
  *&#x2F;
&#x2F;&#x2F;
$.fn.jocodeSlideshow = function(config) {
    
    return this.each(function() {
       
        $.data(this, &#x27;jocodeSlideshow&#x27;, new $.JocodeSlideshow($(this), config));
    });
};

})(jQuery);


    </pre>
</div>
